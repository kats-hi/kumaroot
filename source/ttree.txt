* TTree編

  ROOTを使うにあたって、TTree（もしくは次の章のTChain）は基礎中の基礎
  です[fn::「さるROOT」や、他のウェブサイトでは「TNtuple」をサンプル
  として取り上げていますが、これだけを使っている研究者はみたことがあり
  ません。TTreeのベースにはTNtupleがあるのかもしれませんが、なんでこん
  な使われていないものをサンプルにするのか疑問です]。
  とりあえず、取得したデータはさっさとTTreeに変換してしまいましょう。


** TTreeを作成したい : TTree

   #+begin_src c++
TTree TTree(const char* name, const char* title, Int_t splitlevel = 99)
   #+end_src

   - name :: TTreeオブジェクトの名前。他のオブジェクトと重複しないようにする
   - title :: TTreeの説明。TFileに保存したときに表示される
   - splitlevel :: 使ったことがない

   「name」はオブジェクトの名前です。他のオブジェクトと重複しないよう
   にしましょう。「title」はTFileを覗いた時に表示されるTTreeの説明です。
   １行くらいの簡単な説明をきちんと付けておくとあとで自分自身を救うこ
   とになると思います。「splitlevel」は指定したことがありません。デフォ
   ルト値で大丈夫です。

** テキストファイルをTTreeに変換したい（１）: ReadFile

   #+begin_src c+++
Long64_t ReadFile(const char* filename, const char* branchDescriptor = "", char delimiter = ' ')
   #+end_src

   - filename :: 入力ファイル名
   - branchDescriptor :: 入力ファイルの構造指定。「:」で区切る
   - delimiter :: こんなのあったんだ

   学生実験や小さなテストベンチで行う実験の場合、取得したデータはとり
   あえずテキストファイルで出力することになると思います。ROOTで解析す
   るときはTTreeになっていると楽ちんなので、手間を掛けずにさっさと変換
   してしまいましょう。

   入力ファイルの構造は「branchDescriptor」で、TTreeに教えてあげます。

    - 第１引数 :: 入力ファイル名
    - 第２引数 :: branch descriptor。TTreeのブランチ変数になります。複
                  数のブランチ変数を指定する場合は、コロン（:）で区切っ
                  て記述します。Int_t型の場合は「ブランチ名/I」、
                  Double_t型の場合は「ブランチ名/D」といった感じで、そ
                  の変数名（＝ブランチ名）とその型を指定できます。型を
                  省略した場合はFloat_t型の「ブランチ名/F」になるみた
                  いです。

**** サンプルコード

     仮に、100行４列のテキストファイルがあるとします。
     このファイルの「行数」はイベント数に相当し、「列数」は取得したデータの項目に相当します。

     #+attr_latex: centering
   #+begin_example
100    105    104   103
101    106    103   100
...
   #+end_example

#    #+begin_src bash
# 100    105    104   103
# 101    106    103   100
# ...
#    #+end_src


    #+begin_src c++
{
  // STEP1: Set input filename
  TString ifn = "inputfilename";

  // STEP2: Create TTree
  TTree *tree = new TTree("tree", "tree using ReadFile()");

  // STEP3: Read data using TTree::ReadFile(...) method
  tree->ReadFile(ifn.Data(), "row1/I:row2/I:row3/I:row4/D:row5/I");

  // STEP4: Create TFile to save TTree
  TString ofn = "out.root";
  TFile *fout = new TFile(ofn, "recreate");

  // STEP5: Write TTree to TFile
  tree->Write();

  // STEP6: Close TFile
  fout->Close();

  return;
}
    #+end_src


** テキストファイルをTTreeに変換したい（１）: Branch
*** TTree::Branch() を使う方法

    #+begin_src c++
tree->Branch("run", &run, "run/I")
    #+end_src

    - 第１引数 :: ブランチ名；なんでも良い。用意した変数名と違っていても構わない
    - 第２引数 :: 変数のアドレス；変数が実体の場合は、&を先頭につけて
                  アドレスを指定する。配列の場合はそのまま（array） or
                  最初の配列のアドレス（&array[0]）を指定する。事前に
                  変数を用意しておかないと怒られる
    - 第３引数 :: 変数の型；“変数／型”の形で記述する。int型はI, float
                  型はF, double型はFなど

**** サンプルコード

    よくある方法です。ググればいっぱい見つかります。

    #+begin_src c++
{
    // STEP1: データファイルを読み込む
    TString ifn = "inputfilename"
    ifstream fin;
    fin.open(ifn);

    // STEP2: データを格納するための変数を定義する
    int val1, val2, val3, val4;

    // STEP3: TTreeを作成する
    TTree *tree = new TTree("name", "title);

    // STEP4: TTree::Branch(...)を使って、各変数のブランチを作成する
    tree->Branch("val1", &val1, "val1/I");
    tree->Branch("val2", &val2, "val2/I");
    tree->Branch("val3", &val3, "val3/I");
    tree->Branch("val4", &val4, "val4/I");

    // STEP5: C++でファイルを読み込むときの常套手段
    while (fin >> val1 >> val2 >> val3 >> val4) {
        // STEP6: データのエントリの区切りで必ずTTree::Fill()する
        tree->Fill();
    }

    // STEP7: 作成したTTreeを保存するためのTFileを作成する
    TString ofn = "outputfilename";
    TFile *fout = new TFile(ofn, "recreate");

    // STEP8: TFileにTTreeを書き込む
    tree->Write();  //

    // STEP9: TFileを閉じる
    // プログラム（やマクロ）終了時に勝手に閉じてくれるらしいが一応
    fout->Close();

    return;
}
    #+end_src

    前述したReadFile を使った方法と比べると、コードの行数がぐーんと多
    いことが分かります。（ReadFileの場合、肝となる部分はたったの一行で
    す）。

    行数が増えた分、汎用性が高くなっています。
    こちらの方法だと、ブランチに「配列」を設定することも可能です。


** ブランチに配列を使いたい

   TTree::Branch を理解していれば簡単です。

   #+begin_src c++
int val1[100];
TTree *tree = new TTree("tree", "tree using array");
tree->Branch("val1", val1, "val1[100]/I");
   #+end_src

   第２引数には「変数のアドレス」を指定します。
   val1 は 配列の先頭アドレスを指しているので、＆をつける必要はありません。
   第３引数には、配列の長さをベタ書きします。


*** ブランチに文字列を使いたい

    配列を使うことができるので、文字列のブランチを作ることもできます。

   #+begin_src c++
char hoge[32];
tree->Branch("moji", hoge", "moji[32]/C")
sprintf(hoge, "hogehogefugafuga")
tree->Fill();
   #+end_src


** ブランチに可変長配列を使いたい

   少し手間を加えると可変長配列も扱えます。

   1. 配列の大きさ fN を定義する
   2. 配列 val を定義する
   3. fN のブランチを作る
   4. val のブランチを作る

    #+begin_src c++
Int_t fN;                                 // (1) 設定したい配列の大きさ
Int_t val[max];                           // (2) val[max]: maxはfNよりも大きな数
tree->Branch("nch", &fN, "nch/I");        // (3) まずfNをブランチにセットする；fNだと何の変数か分かりづらいので、nch（全チャンネル数の意）に変更した点に注意
tree->Branch("val", val, "val[nch]/I");   // (4) 次にval[fN]をセットする；maxでも、fNでもなくなく、nchにする点に注意

// (4)を以下のようにすると、"Illegal leaf ..." と怒られる
tree->Branch("val", val, "val[fN]/I");    // fNには、ブランチ名を入れる必要があるらしい（
    #+end_src

*** ブランチに可変長文字列を使いたい

    #+begin_src c++
#include <string.h>    // strlen()を使うために必要

const Int_t NMAX_MOJI = 100;
char hoge[NMAX_MOJI];
Int_t nmoji;
tree->Branch("nmoji", &nmoji, "nmoji/I");
tree->Branch("moji", hoge, "hoge[nmoji]/C");

sprintf(hoge, "hoge-hoge-fuga-ga");
nmoji = strlen(hoge)
tree->Fill()
    #+end_src


*** ブランチにstd::vector を使いたい

    #+begin_src c++
#include <vector>

std::vector<Double_t> vec;
TTree *tree = new TTree("tree", "tree using vector");
tree->Branch("vec", &vec);
    #+end_src

    <vector>をincludeする :: namespaceを定義しない場合は、”std::vector<型
    > 変数名”と宣言すること。当たり前のことだけど、結構忘れてしまう。
    ROOT(CINT)を起動させると、“vector<型> 変数名”で使えてしまうため、
    よく忘れる…orz vector型の変数は実体であるため、第２引数は先頭に
    “&“が必要arrayと同じようにすると怒られるROOTが空気を読んでくれるた
    め、第３引数はなくてよいみたいまぁでも一番最後のブランチにするのが
    無難かも
