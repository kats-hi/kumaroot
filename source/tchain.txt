* TChain編

  TChainを使うと同じ構造のTTreeを複数連結（＝chain）して、ひとつの
  TTreeとして扱うことができます。TTreeを継承したクラスなので、連結した
  後はTTreeと同じように使えばOKです。

** 複数のTTreeを読み込みたい


   #+begin_src c++
TChain *chain=new TChain("tree", "tree title");
   #+end_src

   - 第１引数 :: 読み込むTTreeの名前; 読み込むTTreeの名前と一致してないと怒られる
   - 第２引数 :: タイトル; 説明みたいなもの。なくても大丈夫

   #+begin_src c++
chain->Add("../anadata/CALIB_RUN10.root");
chain->Add("../anadata/CALIB_RUN11.root");
chain->Add("../anadata/CALIB_RUN12.root");
   #+end_src

   - 第１引数 :: ファイル名; ワイルドカード指定もできる

*** サンプルコード : ループで読み込む

    #+begin_src c++
TChain *chain=new TChain("chain", "chainname");
const Int_t fNFile=11;
Int_t iFile;
for (iFile=0; iFile<fNFile; ++iFile) {
    chain->Add(Form("../anadata/CALIB_RUN%d.root", iFile+10));
}
    #+end_src

*** サンプルコード : ワイルドカード指定

    #+begin_src c++
TChain *ch = new TChain("upk");
ch->Add("upk_run*.root")
    #+end_src

** 読み込んだTTreeの数を知りたい

   #+begin_src c++
chain->GetNtrees()
   #+end_src

** 読み込んだTTreeのリストを取得したい

   #+begin_src c++
TObjArray *fileElements = fBsd->GetListOfFiles();
TIter next(fileElements);
TChainElement *chEl = 0;
while (( chEl=(TChainElement*)next() )) {
    fprintf(stdout, "[%s]\tListOfFiles\t'%s'\n", __FUNCTION__, chEl->GetTitle() );
}
   #+end_src

   ROOTマニュアルに載ってた
