#+title:KumaROOT
#+author:しょーた
#+email:  shotakah@post.kek.jp
#+options: H:4

#+latex_class: jsreport
#+latex_header: \hypersetup{bookmarksnumbered=true}
#+latex_header: \hypersetup{bookmarksopen=true}
#+latex_header: \hypersetup{bookmarksopenlevel=2}
#+latex_header: \hypersetup{pdfpagemode=UseOutlines}


# #+latex_class_options: [dvipdfmx, 15pt, report]
#+latex_header: \lstset{language=C++}
# #+latex_header: \lstset{basicstyle=\small}
#+latex_header: \lstset{basicstyle=\scriptsize}
#+latex_header: \lstset{stringstyle=\ttfamily}
#+latex_header: \lstset{commentstyle=\ttfamily}
#+latex_header: \lstset{showstringspaces=false}
#+latex_header: \lstset{frame=shadowbox}
#+latex_header: \lstset{rulesepcolor=\color{black}}
#+latex_header: \lstset{breaklines=true}
#+latex_header: \lstset{tabsize=2}
#+latex_header: \lstset{numbers=left}
#+latex_header: \lstset{numberstyle=\scriptsize}
#+latex_header: \lstset{stepnumber=1}
#+latex_header: \lstset{numbersep=1zw}
#+latex_header: \lstset{fancyvrb=true}
#+latex_header: \fvset{gobble}


* はじめに

  これまで古巣の研究室に設置した
  DokuWiki[fn::http://www-he.scphys.kyoto-u.ac.jp/member/shotakaha/dokuwiki/doku.php]
  にROOTなどの情報を書きためていましたが、そろそろ引っ越しをしなくては
  いけないかもしれません。せっかく書きためたのでどうにかして残しておき
  たいのですが、いまの職場のサーバではPHPなどが一切動かないため、
  GitHubにて公開することにしました。ついでに、動作するサンプルコードも作成して
  いこうと思っています。

** 「くまROOT」の由来

   「くまROOT」と名づけたのは、私がROOTを使い始めたときに、最初に目を通
   した「猿にも使えるROOT」（通称：さるROOT）の知名度にあやかりたかった
   ためです。「さる」の次は「くま」を読んでもらえるように頑張りたいと思います。

   ということで、読者は、ちょっとだけROOTを使ったことがある学生／研究者
   が対象になると思います。できるだけ「逆引き辞典」として使えるようにし
   たいと思います。


** ROOTについて

   「ROOT」とは高エネルギー物理学業界で広く使われている解析フレームワー
   クです。CERNが中心となって開発を行っています。もっとちゃんとした説
   明はそこら辺のウェブに落ちているので、ここでは僕の所感を述べること
   にします。

   「解析フレームワーク」と聞くとたいそうに聞こえますが、「お絵かきソ
   フト」と捉えて気軽に使えば良いと思います。[fn::もちろん、お絵かきと
   いっても、ヒストグラムやグラフが中心になります]。例えば、これまでエ
   クセルで作成していたグラフを、ROOTで作ってみるとか。
   ROOTマクロをひとつ作っておけば、再利用できる範囲はエクセル以上だと思います。

   あと、ROOTを使うにあたり注意事項は一つです。「決して深入りしないこ
   と」。どうにもならん部分は「仕様」と思って諦めましょう。


* 参考サイト

  このKumaROOTに載っている情報は、下記のサイトから集め、自分で試してみたものです。
  本当に詳しいことは下記の情報を自分で読んでみるのが一番かもしれません。

  - [[http://root.cern.ch/drupal/content/users-guide][ROOT公式ユーザーズガイド]] :: 困ったらとりあえず読みましょう！「ROOT
       User's Guide」の項目から自分の読みたいドキュメントを選べばよい
       です。とてーも長いので全部読もうとしてはいけません。必要な時に、
       必要は箇所を、必要なだけ読むようにしましょう。あと、これを書い
       ているときに気づいたのですが、初心者は「ROOT Primer」に目を通し
       てみると良いかもしれません。
  - [[http://root.cern.ch/drupal/content/reference-guide][ROOT公式リファレンスガイド]] :: クラス名やそのメソッド名、内容、使い
       方を知りたい場合に使いましょう！といっても、このページから辿ら
       なくても、「cern root ttree」[fn::検索の際「cern」と付けるのが
       重要です。でないと、管理者の意味の「root」がたくさんヒットしま
       す。]などとGoogle検索すればたいていヒットします。「クラスの説明
       ＋メソッド一覧」という構成になっています。最初は読むのに苦労す
       るかもしれませんが、使いこなせるように頑張りましょう。ROOT中級
       者はみんな使っています。
  - [[http://root.cern.ch/root/html/tutorials/][ROOT公式チュートリアル]] :: 付属のサンプルコードの説明です。ドキュメ
       ントやレファレンスを読むより、実際にコードを動かし、ソースを読
       むほうが早く身につきます。初めて使うクラスなどはとりあえずサン
       プルを動かしてみましょう。
  - [[http://root.cern.ch/drupal/content/c-coding-conventions][ROOT公式コーディングガイド]] :: ROOTのソースコードを読むときに役に立
       つかも。なんとなく知っておくと良いです。覚える必要は全くありま
       せん。
  - [[http://hep.planet-koo.com/index.php?g=root][ROOT解体新書]] by 楠本さん[fn::ページのリンク切れを確認（[2015-01-27 Tue]）] :: gROOT
       や、gStyleの設定など、他のページ／マニュアルでは見られない項
       目がすごく詳しい。
  - [[http://blog.livedoor.jp/oxon/][宇宙線実験の覚え書き（大学院生版）]] by 奥村さん :: PyROOTのことをグ
       グっていてこのページに辿り着きました[fn::青い色のページにお世話
       になってた気がするんだけど、気のせいかな]。いまは [[http://oxon.hatenablog.com][宇宙線実験の
       覚え書き（社会人版）]] にお引っ越ししたみたいです。


* ROOTを使いたい

** オススメのインストール方法（for Mac ユーザ）

   #+begin_src sh
$ sudo port install root5    ## for ROOT5 user
$ sudo port install root6    ## for ROOT6 user
   #+end_src

   さて、まずはインストールしないとはじまりません。Macの場合はMacPorts
   からインストールできるようになっています[fn::Homebrewやfinkなど、そ
   の他のパッケージ管理ツールは使ったことがないので分かりません。誰か
   情報をくださいな]。すごく楽ちんなのでオススメです。環境変数
   （$ROOTSYS、$LD_LIBRARY_PATH、$DYLD_LIBRARY_PATHなど）の設定も不要
   です。

   ROOT6は2014年にリリースされました。MacPortsの場合「root6」というパッ
   ケージ名[fn::正確には「ポート名」かも。あまり気にしないでください。]で
   インストールすることができます。ROOT5と一緒にインストールしてお
   いても大丈夫ですが、一緒には使えません。後述する方法で簡単に切り替
   えることが出来ます。

   現在はROOT5からROOT6へ移行する過渡期です。そのため、進行中の実験は
   ROOT5系を使っていることが多いです[fn::LHC実験の要求に応えるため
   （？）、３年位前からROOTの開発が非常に活発に行われています。しかし、
   その他の実験では、安定性を求め古いバージョン使い続けていることがあ
   ります。あとOSが古いと最新バージョンはうまくインストールできないこ
   ともあります]。むやみに最新版を使うと、実験固有のソフトウェア群が動
   作しないこともあります。その場合は、素直に実験で推奨されているバー
   ジョンには従ってください。

*** Git を使ったインストール方法


    Linuxを使っている場合は、Gitを使うとよいでしょう。
    方法は「[[https://root.cern.ch/drupal/content/installing-root-source][installing-root-source | ROOT公式ページ]]」に載っている通りです。

    #+begin_src sh
    ## STEP1 : make a directory for cloning
    [any]  $ mkdir ~/repos/git
    [any]  $ cd ~/repos/git

    ## STEP2 : clone ROOT repository from CERN
    [git]  $ git clone http://root.cern.ch/git/root.git
    [git]  $ cd root

    ## STEP3 : look for a version
    [root] $ git tag -l

    ## STEP4 : checkout the tag version you want
    [root] $ git checkout -b v5-34-08 v5-34-08

    ## STEP5 : set PREFIX and configure, then make, then make install
    ##       : use tee command for logging output file when building and installing
    [root(v5-34-08)] $ ./configure --prefix=/usr/local/heplib/ROOT/v5-34-08
    [root(v5-34-08)] $ make 2>&1 | tee make.log                   ## buiding ROOT
    [root(v5-34-08)] $ make install 2>&1 | tee makeinstall.log    ## installed under $PREFIX
    #+end_src

    1. 本体をどこかにcloneする（今回は、~/repos/git/ 以下）
    2. どんなタグがあるのかを調べる
    3. 目的のバージョンのタグ名が分かったら、そのタグをチェックアウト
       します。ブランチ名は好きにしてかまいません（今回は、タグ名と同
       じ名前）。
    4. あとは、従来通りPREFIXを指定してconfigureします。configure の内
       容は たしか config.status に書きだされます。make、make install
       の際、PREFIXで指定したディレクトリによっては sudo が必要です。
       また、失敗した場合に備えてログを残しておくとよいです。今回は、
       teeコマンドを使うことで、端末に表示しながらログファイルに保存し
       ています。

    あとは、~/.bashrc に環境変数の設定を書いておきます。

*** 従来のインストール方法

    ググればたくさん出てきますが、一応紹介しておきます。

    #+begin_src sh
## STEP1 : make directory for tar.gz file and wget it
$ cd /usr/local/heplib/tarballs
$ wget ftp://root.cern.ch/root/root_v5.30.06.source.tar.gz    ## check URL at ROOT website

## STEP2 : expand tar.gz
[ROOT] $ cd /usr/loca/heplib/ROOT
[ROOT] $ tar zxvf ../tarballs/root_v5.30.06.source.tar.gz

## STEP3 : set PREFIX then configure -> make -> make install
[ROOT] $ cd root
[root] $ ./configure --prefix=/usr/local/heplib/ROOT/v5-30-06
[root] $ make 2>&1 | tee make.log
[root] $ make install 2>&1 | tee makeinstall.log
    #+end_src

*** インストール方法 for Windows ユーザ

    Windowsはよく分かりません。ごめんなさい。たぶん
    「[[https://root.cern.ch/drupal/content/downloading-root][downloading-root | ROOT公式ページ]]」から目的のバージョンを選び、
    そこからバイナリを落としてくるのが一番簡単だと思います。


** ROOT5 と ROOT6 を試してみたい

   #+BEGIN_SRC sh
$ sudo port select root root6   ## use ROOT6
$ sudo port select root root5   ## use ROOT5
   #+END_SRC

   MacPortsでROOTをインストールする利点のひとつは、ROOT5 と ROOT6 が簡単に切り
   替えられることです。

   実はこの「port select」はROOTだけでなく、Pythonのバージョン切り替えなどもできます。
   どのパッケージが使えるかは以下のコマンドで確認できます

   #+begin_src sh
$ port select --summary
   #+end_src


*** ROOT5 と ROOT6 の違いについて

    ROOTマクロなどを実行する際に使うインタプリタが変更されたみたいです
    [fn::CINT \rightarrow CINT++に変更]。細かい違いは全く分かりません
    が、文法のチェックが厳密になったみたいです。

    実はROOT5ではC言語／C++言語の文法的には間違っているマクロでも動い
    てくれました[fn::よく知られていると思われるのは、a.b でも a->bでも
    動いちゃうことでしょうか]。そのため、テストで作ったマクロで動作確
    認した後、より多くのデータを解析するためにコンパイルするとエラーが
    多出。そのデバッグに追われるということは日常茶飯事でした。

    ROOT6では、このマクロの文法チェックも厳しくなったみたいです。ひぇぇ。
    でも心配しなくて大丈夫。エラーの内容を詳しく教えてくれるようになり
    ました。よくある行末のセミコロンのつけ忘れなども指摘してくれます。
    これで場所の分からない segmentation fault に悩まされることも減るで
    しょう。

    試しに、ROOT5のチュートリアルをROOT6で実行してみてください。
    「warning」や「error」がたくさん表示されます。

    #+begin_src sh
## STEP1 : set to ROOT6
$ sudo port select root root6

## STEP2 : move to tutorials/ directory of ROOT5
$ cd /opt/local/libexec/root5/share/doc/root/tutorials/

## STEP3 : start ROOT（=ROOT6）
$ root

## ===  an example of warning ===
/opt/local/libexec/root5/share/doc/root/tutorials/rootalias.C:7:13:
 warning: using the result of an assignment as a condition without
 parentheses [-Wparentheses]
      if (e = getenv("EDITOR"))
          ~~^~~~~~~~~~~~~~~~~~
## === an example of error ===

/opt/local/libexec/root5/share/doc/root/tutorials/rootalias.C:39:12:
 error: cannot initialize return object of type 'char *' with an rvalue of
 type 'const char *'
    return gSystem->WorkingDirectory();
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~

$ .q
    #+end_src

** PyROOTを使いたい

   #+begin_src sh
$ sudo port install root5 +python27   ## when ROOT5, you need to specify +pythonXX variants
$ sudo port install root6             ## when ROOT6, no need to specify variants
   #+END_SRC

   CERNには「へびつかい」が多いらしく、「PyROOT[fn::実は [[http://www.rootpy.org][rootpy]] という
   のもあります。こっちのほうがPython nativeな感じです。前に試そうとし
   てたのですがインストールでコケてしまいました。動かせたら項目を作る
   かも]」というモジュールを使えば、Python上でROOTが使えるようになって
   います。

   その場合は、MacPortsでインストールする際に variants で指定する必要
   があります。しかも、この variantsは自分の使っているPythonのバージョ
   ンに合わせる必要があります。ミスマッチな場合は、動作しません（＝ク
   ラッシュします）。

   ROOT6の場合はpython27 がデフォルトでONになっています。

** EmacsでROOTを編集したい

   #+begin_src sh
$ locate root-help.el    # check path
   #+end_src


   これもあまり知られていないと思うのですが、Emacs上でROOTのソースを編
   集するのを簡単にするElispパッケージが一緒にインストールされます。
   locateコマンドでどこにあるか調べておきましょう。

   ちなみに、僕の場合（＝MacPortsの場合）、以下にありました。

   #+begin_src sh
/opt/local/libexec/root5/share/emacs/site-lisp/root-help.el
/opt/local/libexec/root6/share/emacs/site-lisp/root-help.el
   #+end_src

   これの使い方に関しては、あとできちんと調べて書くことにします。

** ROOTのtutorialを使いたい

   #+begin_src sh
/opt/local/libexec/root5/share/doc/root/tutorials/     ## ROOT5
/opt/local/libexec/root6/share/doc/root/tutorials/     ## ROOT6
   #+end_src

   実はROOTをインストールすると、たくさんのサンプルコードもついてきま
   す。使い方をウェブで検索してもよく分からない場合は、このサンプルコー
   ドを動かしながら中身をいじくってみるのが一番です。

   とりあえず、いつでも使えるようにテスト用ディレクトリを作成しコピー
   しておきましょう。以下に一例を示しましたが、自分の環境に合わせて適
   宜変更してください。

   #+begin_src sh
$ cp -r /opt/local/libexec/root5/share/doc/root/tutorials ~/TEST/root5/
$ cp -r /opt/local/libexec/root6/share/doc/root/tutorials ~/TEST/root6/
   #+end_src

   cp コマンドを使う際には、-r オプションを付けることでサブディレクト
   リもコピーできます。その際、コピー元（＝第１引数）の最後に「/」付け
   てはいけません。コピー先（＝第２引数）の最後には「/」を付けてもよい
   です（もしかしたらなくてもよいのかも）[fn::この辺はよく忘れます。失
   敗したらコピー先を削除すればいいだけなので、失敗もしてみてください]。

* ROOT tutorial 編

  この章では、主にROOTに付属しているtutorialを使用して、使い方を簡単に紹介します。
  前節の最後にも書きましたが、手元にコピーを作っておきましょう。

  #+begin_src sh
$ cp -r /opt/local/libexec/root6/share/doc/root/tutorials ~/TEST/root6/
  #+end_src

  とりあえずROOT6のtutorialを使います。気が向いたらROOT5との比較もしよ
  うかと思います。

** とりあえず起動

   #+begin_src sh
$ cd ~/TEST/root6/tutorials/
$ root

root[0]
   #+end_src

   コマンドラインで「root」と入力すると、ROOTが起動します。
   この状態だと、対話的にROOTを操作することができます。

** とりあえず終了

   #+begin_src sh
root [0] .q
   #+end_src

   ROOTセッション内で「.q」を入力すると、ROOTが終了します。
   それで終了しない場合は、「.qqq・・・」の様にqをたくさんにします。

*** rootlogon.Cとrootlogoff.C

    さて、tutorials をコピーしたディレクトリでROOTを起動／終了すると、
    以下の様なメッセージが表示されたはずです。

   #+begin_src bash
Welcome to the ROOT tutorials

Type ".x demos.C" to get a toolbar from which to execute the demos

Type ".x demoshelp.C" to see the help window

==> Many tutorials use the file hsimple.root produced by hsimple.C
==> It is recommended to execute hsimple.C before any other script

root [0]
   #+end_src

    #+begin_src bash
Taking a break from ROOT? Hope to see you back!
   #+end_src

    これは、同じディレクトリに、「rooglogon.C」と「rootlogoff.C」があるからです。
    この２つのファイルを用意しておくことで、ROOT起動時および終了時の動作を設定することができます。

    個人的には、数ヶ月ぶりに触るプログラムなんてほとんど忘れてしまっているので、
    rootlogon.C に手順を書いて残したりしています。

*** ROOT起動時に読み込まれるファイルの順番

    ROOT起動時に以下の順番でファイルが読み込まれます。

   1. system.rootrc
   2. ~/.rootrc
   3. ./rootlogon.C

   個人的な全体設定は「~/.rootrc」へ、そのプログラムだけの設定は「./rootlogon.C」に書いておけばよいです。

** demos.Cを実行してみる

   さて、ROOTを起動して表示されたメッセージにしたがって、demos.C を実
   行してみましょう。ROOT内で実行する場合は、「.x ファイル名」と入力し
   ます。ファイル名の部分はTAB補完ができます。これをbashで実行する場合
   は以下のようにします。

   #+begin_src sh
$ root demos.C
   #+end_src

   さてさて、実行すると図[[fig:demos]]のようなツールバーが出てきます。

   #+attr_latex: :height 10cm
   #+name: fig:demos
   #+caption: demos.Cを実行した時に出てくるツールバー的なもの
   [[./fig/demos.png]]


   一番上にある、「Help Demos」をクリックすると、図[[fig:helpdemos]]のよう
   なキャンバスが表示されます。

   #+attr_latex: :height 10cm :mode hoge
   #+name: fig:helpdemos
   #+caption: Help Demos を実行すると出てくるキャンバス
   [[./fig/helpdemos.png]]

   とりあえずこの通りにボタンを押してみましょう。

** hsimple.Cを実行してみる

   #+begin_src sh
$ root hsimple.C
   #+end_src

   前節のようにボタンを押して実行するか、上の行の様にコマンドラインか
   ら「hsimple.C」を走らせると、キャンバスが表示され、ヒストグラムが成
   長していきます。それと同時に、「hsimple.root」というROOTファイルが
   作成されます。

   「hsimple.C」を開いて、上から順番に何をしているのかを確認してみましょ
   う。

*** インクルードファイル

    とりあえず無視してOKです。コンパイルする場合は必要ですが、マクロで
    動かす場合は書かなくてもよいです。

# #+include: "./root6/tutorials/hsimple.C" src c++ :lines "1-12"

#+begin_src c++
#include <TFile.h>
#include <TNtuple.h>
#include <TH2.h>
#include <TProfile.h>
#include <TCanvas.h>
#include <TFrame.h>
#include <TROOT.h>
#include <TSystem.h>
#include <TRandom3.h>
#include <TBenchmark.h>
#include <TInterpreter.h>
#+end_src

*** 関数の定義

    マクロの場合ファイル名と関数名は一緒にします。
    戻り型はなんでもOKです。引数を指定することもできます。
#+begin_src c++
TFile *hsimple(Int_t get=0)
#+end_src

*** コメントの挿入

    コメントはC++の作法で挿入できます

#+begin_src c++
{
//  This program creates :
//    - a one dimensional histogram
//    - a two dimensional histogram
//    - a profile histogram
//    - a memory-resident ntuple
//
//  These objects are filled with some random numbers and saved on a file.
//  If get=1 the macro returns a pointer to the TFile of "hsimple.root"
//          if this file exists, otherwise it is created.
//  The file "hsimple.root" is created in $ROOTSYS/tutorials if the caller has
//  write access to this directory, otherwise the file is created in $PWD
#+end_src

*** ファイル名の宣言

    TStringクラスという文字列クラスを使っています。
    普通のC/C++の関数を使うよりはるかに楽なので、積極的に使うと良いと思います。

#+begin_src c++
   TString filename = "hsimple.root";
   TString dir = gSystem->UnixPathName(__FILE__);
   dir.ReplaceAll("hsimple.C","");
   dir.ReplaceAll("/./","/");
   TFile *hfile = 0;
   if (get) {
      // if the argument get =1 return the file "hsimple.root"
      // if the file does not exist, it is created
      TString fullPath = dir+"hsimple.root";
      if (!gSystem->AccessPathName(fullPath,kFileExists)) {
         hfile = TFile::Open(fullPath); //in $ROOTSYS/tutorials
         if (hfile) return hfile;
      }
      //otherwise try $PWD/hsimple.root
      if (!gSystem->AccessPathName("hsimple.root",kFileExists)) {
         hfile = TFile::Open("hsimple.root"); //in current dir
         if (hfile) return hfile;
      }
   }
   //no hsimple.root file found. Must generate it !
   //generate hsimple.root in current directory if we have write access
   if (gSystem->AccessPathName(".",kWritePermission)) {
      printf("you must run the script in a directory with write access\n");
      return 0;
   }
#+end_src

*** ROOTファイルを開く

    TFileクラスを使います。直前のif文の中ではファイルの存在を確認して
    います。ファイルがある場合は、TFile::Openメソッドでファイルを開い
    ています。ない場合は、TFile::TFileコンストラクタで新しいTFileオブ
    ジェクトを作成しています。

#+begin_src c++
   TFile *hfile = 0;

   hfile = TFile::Open(fullPath); //in $ROOTSYS/tutorials
   hfile = TFile::Open("hsimple.root"); //in current dir

   hfile = (TFile*)gROOT->FindObject(filename); if (hfile) hfile->Close();
   hfile = new TFile(filename,"RECREATE","Demo ROOT file with histograms");
#+end_src

*** ヒストグラムを作成する

    TH1クラス、TH2クラスなどを使います。
    ここでは、TProfileクラスやTNtupleクラスも使われています。

#+begin_src c++
   // Create some histograms, a profile histogram and an ntuple
   TH1F *hpx = new TH1F("hpx","This is the px distribution",100,-4,4);
   hpx->SetFillColor(48);
   TH2F *hpxpy = new TH2F("hpxpy","py vs px",40,-4,4,40,-4,4);
   TProfile *hprof = new TProfile("hprof","Profile of pz versus px",100,-4,4,0,20);
   TNtuple *ntuple = new TNtuple("ntuple","Demo ntuple","px:py:pz:random:i");
#+end_src

*** プロセス時間の測定開始

    このマクロを実行すると、ターミナル上にプロセス時間が表示されます。
    この部分から測定を開始しています。

#+begin_src c++
   gBenchmark->Start("hsimple");
#+end_src

*** キャンバスの作成

    グラフを描く領域をキャンバスと呼びます。TCanvasクラスを使います。

#+begin_src c++
   // Create a new canvas.
   TCanvas *c1 = new TCanvas("c1","Dynamic Filling Example",200,10,700,500);
   c1->SetFillColor(42);
   c1->GetFrame()->SetFillColor(21);
   c1->GetFrame()->SetBorderSize(6);
   c1->GetFrame()->SetBorderMode(-1);
#+end_src

*** ヒストグラムに値を詰める

    このマクロでは、ヒストグラムにランダムな値を詰め込んでいます。

#+begin_src c++
   // Fill histograms randomly
   TRandom3 random;
   Float_t px, py, pz;
   const Int_t kUPDATE = 1000;
   for (Int_t i = 0; i < 25000; i++) {
      random.Rannor(px,py);
      pz = px*px + py*py;
      Float_t rnd = random.Rndm(1);
      hpx->Fill(px);
      hpxpy->Fill(px,py);
      hprof->Fill(px,pz);
      ntuple->Fill(px,py,pz,rnd,i);
#+end_src

*** キャンバスに描画する

    TH1::Draw()メソッドで描画します。

#+begin_src c++
      if (i && (i%kUPDATE) == 0) {
         if (i == kUPDATE) hpx->Draw();
         c1->Modified();
         c1->Update();
         if (gSystem->ProcessEvents())
            break;
      }
   }
#+end_src

*** プロセス時間の表示

#+begin_src c++
   gBenchmark->Show("hsimple");
#+end_src

*** ROOTファイルに保存する

#+begin_src c++
   // Save all objects in this file
   hpx->SetFillColor(0);
   hfile->Write();
   hpx->SetFillColor(48);
   c1->Modified();
   return hfile;

// Note that the file is automatically close when application terminates
// or when the file destructor is called.
}
#+end_src


* 全体設定編
** 初期設定したい（rootrc, rootlogon.C）

*** rootrc

    bashの設定を ~/.bashrc に書くように、ROOTの設定は ~/.rootrc に書き
    ます。デフォルト値は、{ROOTをインストールしたパス}/etc/system.rootrc
    に書かれているので、とりあえずこれをホームディレクトリにコピーして
    編集したらOKです。

#+begin_src sh
$ locate system.root
# $ROOTSYS/etc/system.rootrc
$ cp $ROOTSYS/etc/system.rootrc ~/.rootrc
#+end_src

*** rootlogon.C


** キャンバスを無地にしたい（gROOT $\rightarrow$ SetStyle）

#+begin_src c++
gROOT->SetStyle("Plain");
#+end_src

   ROOT v5.30 からキャンバスの色がデフォルトで無地になりました。
   なので、それ以降のバージョンを使っている場合、特に設定は必要ありません。

   （いないと思いますが）昔のキャンバス（＝灰色っぽいやつ）を使いたい場
   合は、"Classic"を指定します。

** 統計情報を表示したい（gStyle->SetOptStat）


   ヒストグラムを描画すると、右上にそのヒストグラムの情報が表示されます。
   デフォルトだと３つしか表示されないので、少し増やしておきます。

#+begin_src c++
gStyle->SetOptStat(112211)
#+end_src

   引数はビットのようなものを表しています。
   このビットは右から読まれます。最大で９くらいまでいける気がする。
   0 or 書かなければ「非表示」、1は「表示」、2は「エラー表示」です。


** フィットの結果を表示したい（gStyle->SetOptFit）

#+begin_src c++
gStyle->SetOptFit(1111111)
#+end_src

   ビットの使い方は、ひとつ前の「統計情報を表示したい」と同じです。


** ヒストグラムの線の太さを一括で変更したい（gStyle->SetHistLineWidth）

   ヒストグラムの外枠線の太さは、一括で設定しておくことができます。デ
   フォルトだと少し細い気がするので、太くしておくとよいと思います。た
   だし、たくさんのヒストグラムを描く際は、見えにくくなってしまうので
   細くします。その辺りは臨機応変にお願いします。

#+begin_src c++
gStyle->SetHistLineWidth(2)
#+end_src

** デフォルトの色を変更したい（gROOT->GetColor->SetRGB）

#+begin_src c++
gROOT->GetColor(3)->SetRGB(0., 0.7, 0.); // Green  (0, 1, 0)->(0, 0.7, 0)
gROOT->GetColor(5)->SetRGB(1., 0.5, 0.); // Yellow (1, 1, 0)->(1, 0.5, 0)
gROOT->GetColor(7)->SetRGB(0.6, 0.3, 0.6); // Cyan (0, 1, 1)->(0.6, 0.3, 0.6)
#+end_src

   デフォルトは（1:黒, 2:赤, 3:黄, 4:青, 5:黄緑, 6:マゼンダ, 7:シアン）なのですが、
   この中で、（3:黄, 5:黄緑, 7:シアン）は明るすぎてとても見えづらいので、
   もう少し見やすい色に変更します。

   上２つは奥村さんのページのコピペ、最後のはシアンを紫っぽい色に変更しました。

   RGBの度合いは自分の好みで選んでください。
   手順としては、RGBの値を検索（Wikipedia使用すると良い）→ その値を256（ほんとは255かも？）で割るだけです。

   おまけとして、ROOT公式ブログの「[[http://root.cern.ch/drupal/content/rainbow-color-map][虹色カラーマップを使うこと]]」 の記事もリンクしておきます。


** 横軸に時間を使いたい（SetTimeFormat, SetTimeDisplay）

   #+begin_src C++
   gStyle->SetTimeOffset(-788918400);    // set diff. btw Unix and ROOT epoch
   graph->GetXaxis()->SetTimeDisplay(1);
   graph->GetXaxis()->SetTimeFormat("%Y\/%m\/%d");
   graph->GetXaxis()->SetTimeOffset(0, "gmt");    // set GMT+0
   #+end_src

   Unixのepoch time は1970年01月01日00時00分00秒から始まるのに対し、
   ROOTのepoch time は1995年01月01日00時00分00秒から始まるので、
   その差をオフセットとして設定する必要がある。

*** Unix epoch と ROOTepochの差を計算する

    簡単な計算なので確かめてみる

    #+begin_src sh
    25[years] * 365[days/year * 24[hours/day] * 60[minutes/hour] * 60[seconds/minute]
    + 6[days] * 24[hours/day] * 60[minutes/hour] * 60[seconds/minutes]    // 6 leap year in 25 years
    = 788918400[seconds]
    #+end_src

*** GMT+0に設定する

    #+begin_src C++
    graph->GetXaxis()->SetTimeOffset(0, "gmt");
    #+end_src

    理由は忘れてしまったが、上の設定をしないと軸の時間がずれてしまってたはず。
    epochの時間ではなく、作成したグラフ／ヒストグラムの軸に対して設定する

*** 月日と時刻を2段にして表示したい

    #+begin_src C++
    graph->GetXaxis()->SetTimeFormat("#splitline{/%m\/%d}{%H:%M}");
    #+end_src

    時間に対する安定性を示したい場合などに使える。


** キャンバスに補助線を描きたい（gStyle->SetPadGridX）

   #+begin_src C++
   gStyle->SetPadGridX(1)    // X-axis grid
   gStyle->SetPadGridY(1)    // Y-axis grid
   #+end_src


** グラフの軸を一括してログ表示にする（gStyle->SetOptLogx）

   #+begin_src C++
   gStyle->SetOptLogx(1)    // X-axis
   gStyle->SetOptLogy(1)    // Y-axis
   #+end_src


** 軸の目盛り間隔を変更したい（gStyle->SetNdivisions）

   #+begin_src C++
   gStyle->SetNdivisions(TTSSPP)
   #+end_src

   - PP :: 軸全体の分割数
   - SS :: PP分割された目盛り１つ分の分割数
   - TT :: SS分割された目盛り１つ分の分割数

   デフォルトは510になっている。PP=10、SS=05、TT=00なので、軸を10分割
   してその１目盛りを5分割、ということで全体で50目盛りになる。

   全体を100目盛りにするには、20510にすればよい。（10分割、その１目盛
   りを5分割、さらにその1目盛りを2分割 ＝100目盛り）


* ヒストグラム編


** １次元ヒストグラムを作成したい : TH1D

   ヒストグラムは以下の手順で作成・描画します。
   1. ヒストグラムのオブジェクトの作成
   2. ヒストグラムに値を詰める
   3. ヒストグラムをキャンバスに描画する

   それらに必要なROOTのクラス・メソッドは以下通りです。

#+begin_src c++
TH1D TH1D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup)
Int_t Fill(Double_t x)
void Draw(Option_t* option = "")
#+end_src


   - TH1D :: １次元ヒストグラム（Double型）のコンストラクタ。
     - name :: オブジェクト名。他のオブジェクト（ヒストグラムだったり、キャンバスだったり）と重複しないようにする。
     - title :: ヒストグラム全体のタイトル。X軸、Y軸のタイトルも同時に設定することができる。
     - nbinsx :: X軸のビンの数。X軸を何分割するか決める。
     - xlow :: X軸の最小値
     - xup :: X軸の最大値
   - Fill :: ヒストグラムに値を詰めるメソッド
   - Draw :: ヒストグラムを描くメソッド。描画のオプションを設定できる。

#+begin_src c++
TString hname, htitle;
hname.Form("hname");    // <------------------------ object name of histogram
htitle.Form("title;xtitle;ytitle;");    // <-------- title and axis name
Double_t xmin = 0, xmax = 10;    // <--------------- left edge and right edge
Int_t xbin = (Int_t)xmax - (Int_t)xmin;    // <----- number of bins

TH1D *h1 = new TH1D(hname.Data(), htitle.Data(), xbin, xmin, xmax);
#+end_src

   - ヒストグラムに限らずROOTオブジェクトには「名前」をセットする必要がある
   - タイトル部分を「;」で区切ることで、軸名を設定することができる（"タイトル;X軸名;Y軸名前"）
   - TString::Form は printf の書式が使えるのでとても便利

** ２次元ヒストグラムを作成したい : TH2D

   #+begin_src c++
TH2D TH2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup)
Int_t Fill(Double_t x, Double_t y)
void Draw(Option_t* option = "")
   #+end_src


** タイトルを変更したい : SetTitle

   #+begin_src c++
void SetTitle(const char* title = "") 	// *MENU*
   #+end_src

** 統計ボックスを表示したい : SetStats

   #+begin_src c++
void SetStats(Bool_t stats = kTRUE) 	// *MENU*
   #+end_src


** X軸名を設定したい : SetXTitle

   #+begin_src c++
void SetXTitle(const char* title)
   #+end_src

** タイトルを中心にしたい


** 平均値、RMSを知りたい : GetMean, GetRMS

   #+begin_src c++
Double_t GetMean(Int_t axis = 1) const
Double_t GetRMS(Int_t axis = 1) const
   #+end_src

** 値を詰めたい : Fill

** 面積でノーマライズしたい

** ２軸グラフを作成したい

   「tutorials/hist/twoscales.C」を参考にする

* TTree編

  ROOTを使うにあたって、TTree（もしくは次の章のTChain）は基礎中の基礎
  です[fn::「さるROOT」や、他のウェブサイトでは「TNtuple」をサンプル
  として取り上げていますが、これだけを使っている研究者はみたことがあり
  ません。TTreeのベースにはTNtupleがあるのかもしれませんが、なんでこん
  な使われていないものをサンプルにするのか疑問です]。
  とりあえず、取得したデータはさっさとTTreeに変換してしまいましょう。


** テキストファイルをTTreeに変換したい

   取得したデータはとりあえずテキストデータとして保存するのが一番簡単
   な方法です。そして、ROOTで解析するときはTTreeになっていると楽ちんで
   す。なので、手間を掛けずにさっさと変換してしまいましょう。

*** TTree::ReadFile を使う方法

    データがテキストファイルで保存されている場合、
    それをTTreeに変換する最も簡単な方法です。

    #+begin_src c++
  tree->ReadFile(ifn.Data(), "row1/I:row2/I:row3/I:row4/D:row5/I");
    #+end_src

    - 第１引数 :: 入力ファイル名
    - 第２引数 :: branch descriptor。TTreeのブランチ変数になります。複
                  数のブランチ変数を指定する場合は、コロン（:）で区切っ
                  て記述します。Int_t型の場合は「ブランチ名/I」、
                  Double_t型の場合は「ブランチ名/D」といった感じで、そ
                  の変数名（＝ブランチ名）とその型を指定できます。型を
                  省略した場合はFloat_t型の「ブランチ名/F」になるみた
                  いです。

**** サンプルコード

     仮に、100行４列のテキストファイルがあるとします。
     このファイルの「行数」はイベント数に相当し、「列数」は取得したデータの項目に相当します。

     #+attr_latex: centering
   #+begin_example
100    105    104   103
101    106    103   100
...
   #+end_example

#    #+begin_src bash
# 100    105    104   103
# 101    106    103   100
# ...
#    #+end_src


    #+begin_src c++
{
  // STEP1: Set input filename
  TString ifn = "inputfilename";

  // STEP2: Create TTree
  TTree *tree = new TTree("tree", "tree using ReadFile()");

  // STEP3: Read data using TTree::ReadFile(...) method
  tree->ReadFile(ifn.Data(), "row1/I:row2/I:row3/I:row4/D:row5/I");

  // STEP4: Create TFile to save TTree
  TString ofn = "out.root";
  TFile *fout = new TFile(ofn, "recreate");

  // STEP5: Write TTree to TFile
  tree->Write();

  // STEP6: Close TFile
  fout->Close();

  return;
}
    #+end_src


*** TTree::Branch() を使う方法

    #+begin_src c++
tree->Branch("run", &run, "run/I")
    #+end_src

    - 第１引数 :: ブランチ名；なんでも良い。用意した変数名と違っていても構わない
    - 第２引数 :: 変数のアドレス；変数が実体の場合は、&を先頭につけて
                  アドレスを指定する。配列の場合はそのまま（array） or
                  最初の配列のアドレス（&array[0]）を指定する。事前に
                  変数を用意しておかないと怒られる
    - 第３引数 :: 変数の型；“変数／型”の形で記述する。int型はI, float
                  型はF, double型はFなど

**** サンプルコード

    よくある方法です。ググればいっぱい見つかります。

    #+begin_src c++
{
    // STEP1: データファイルを読み込む
    TString ifn = "inputfilename"
    ifstream fin;
    fin.open(ifn);

    // STEP2: データを格納するための変数を定義する
    int val1, val2, val3, val4;

    // STEP3: TTreeを作成する
    TTree *tree = new TTree("name", "title);

    // STEP4: TTree::Branch(...)を使って、各変数のブランチを作成する
    tree->Branch("val1", &val1, "val1/I");
    tree->Branch("val2", &val2, "val2/I");
    tree->Branch("val3", &val3, "val3/I");
    tree->Branch("val4", &val4, "val4/I");

    // STEP5: C++でファイルを読み込むときの常套手段
    while (fin >> val1 >> val2 >> val3 >> val4) {
        // STEP6: データのエントリの区切りで必ずTTree::Fill()する
        tree->Fill();
    }

    // STEP7: 作成したTTreeを保存するためのTFileを作成する
    TString ofn = "outputfilename";
    TFile *fout = new TFile(ofn, "recreate");

    // STEP8: TFileにTTreeを書き込む
    tree->Write();  //

    // STEP9: TFileを閉じる
    // プログラム（やマクロ）終了時に勝手に閉じてくれるらしいが一応
    fout->Close();

    return;
}
    #+end_src

    前述したReadFile を使った方法と比べると、コードの行数がぐーんと多
    いことが分かります。（ReadFileの場合、肝となる部分はたったの一行で
    す）。

    行数が増えた分、汎用性が高くなっています。
    こちらの方法だと、ブランチに「配列」を設定することも可能です。


** ブランチに配列を使いたい

   TTree::Branch を理解していれば簡単です。

   #+begin_src c++
int val1[100];
TTree *tree = new TTree("tree", "tree using array");
tree->Branch("val1", val1, "val1[100]/I");
   #+end_src

   第２引数には「変数のアドレス」を指定します。
   val1 は 配列の先頭アドレスを指しているので、＆をつける必要はありません。
   第３引数には、配列の長さをベタ書きします。


*** ブランチに文字列を使いたい

    配列を使うことができるので、文字列のブランチを作ることもできます。

   #+begin_src c++
char hoge[32];
tree->Branch("moji", hoge", "moji[32]/C")
sprintf(hoge, "hogehogefugafuga")
tree->Fill();
   #+end_src


** ブランチに可変長配列を使いたい

   少し手間を加えると可変長配列も扱えます。

   1. 配列の大きさ fN を定義する
   2. 配列 val を定義する
   3. fN のブランチを作る
   4. val のブランチを作る

    #+begin_src c++
Int_t fN;                                 // (1) 設定したい配列の大きさ
Int_t val[max];                           // (2) val[max]: maxはfNよりも大きな数
tree->Branch("nch", &fN, "nch/I");        // (3) まずfNをブランチにセットする；fNだと何の変数か分かりづらいので、nch（全チャンネル数の意）に変更した点に注意
tree->Branch("val", val, "val[nch]/I");   // (4) 次にval[fN]をセットする；maxでも、fNでもなくなく、nchにする点に注意

// (4)を以下のようにすると、"Illegal leaf ..." と怒られる
tree->Branch("val", val, "val[fN]/I");    // fNには、ブランチ名を入れる必要があるらしい（
    #+end_src

*** ブランチに可変長文字列を使いたい

    #+begin_src c++
#include <string.h>    // strlen()を使うために必要

const Int_t NMAX_MOJI = 100;
char hoge[NMAX_MOJI];
Int_t nmoji;
tree->Branch("nmoji", &nmoji, "nmoji/I");
tree->Branch("moji", hoge, "hoge[nmoji]/C");

sprintf(hoge, "hoge-hoge-fuga-ga");
nmoji = strlen(hoge)
tree->Fill()
    #+end_src


*** ブランチにstd::vector を使いたい

    #+begin_src c++
#include <vector>

std::vector<Double_t> vec;
TTree *tree = new TTree("tree", "tree using vector");
tree->Branch("vec", &vec);
    #+end_src

    <vector>をincludeする :: namespaceを定義しない場合は、”std::vector<型
    > 変数名”と宣言すること。当たり前のことだけど、結構忘れてしまう。
    ROOT(CINT)を起動させると、“vector<型> 変数名”で使えてしまうため、
    よく忘れる…orz vector型の変数は実体であるため、第２引数は先頭に
    “&“が必要arrayと同じようにすると怒られるROOTが空気を読んでくれるた
    め、第３引数はなくてよいみたいまぁでも一番最後のブランチにするのが
    無難かも


* TChain編

  TChainを使うと同じ構造のTTreeを複数連結（＝chain）して、ひとつの
  TTreeとして扱うことができます。TTreeを継承したクラスなので、連結した
  後はTTreeと同じように使えばOKです。

** 複数のTTreeを読み込みたい


   #+begin_src c++
TChain *chain=new TChain("tree", "tree title");
   #+end_src

   - 第１引数 :: 読み込むTTreeの名前; 読み込むTTreeの名前と一致してないと怒られる
   - 第２引数 :: タイトル; 説明みたいなもの。なくても大丈夫

   #+begin_src c++
chain->Add("../anadata/CALIB_RUN10.root");
chain->Add("../anadata/CALIB_RUN11.root");
chain->Add("../anadata/CALIB_RUN12.root");
   #+end_src

   - 第１引数 :: ファイル名; ワイルドカード指定もできる

*** サンプルコード : ループで読み込む

    #+begin_src c++
TChain *chain=new TChain("chain", "chainname");
const Int_t fNFile=11;
Int_t iFile;
for (iFile=0; iFile<fNFile; ++iFile) {
    chain->Add(Form("../anadata/CALIB_RUN%d.root", iFile+10));
}
    #+end_src

*** サンプルコード : ワイルドカード指定

    #+begin_src c++
TChain *ch = new TChain("upk");
ch->Add("upk_run*.root")
    #+end_src

** 読み込んだTTreeの数を知りたい

   #+begin_src c++
chain->GetNtrees()
   #+end_src

** 読み込んだTTreeのリストを取得したい

   #+begin_src c++
TObjArray *fileElements = fBsd->GetListOfFiles();
TIter next(fileElements);
TChainElement *chEl = 0;
while (( chEl=(TChainElement*)next() )) {
    fprintf(stdout, "[%s]\tListOfFiles\t'%s'\n", __FUNCTION__, chEl->GetTitle() );
}
   #+end_src

   ROOTマニュアルに載ってた

* TFile編
* TCanvas編

** 色見本を見たい

   ROOTのプロンプト内で下のように入力すると、簡単に確認できる。

   #+begin_src c++
root> TCanvas c
root> c.DrawColorTable()
   #+end_src


** グラフの軸をログ表示にしたい

   #+begin_src c++
TCanvas *c1;
c1->SetLogy();
   #+end_src

*** キャンバスを分割している場合

    まず、分割したいキャンバスに移動する

    #+begin_src c++
c1->cd(2)->SetLogy();
h1->Draw();
    #+end_src

    gPadは current canvas へのポインタなので、下のようにも書くことができる。

    #+begin_src c++
c1->cd(2);
gPad->SetLogy();
    #+end_src

** 複数のキャンバスをPDFに保存したい

   PDF形式で保存する場合のみ、複数のキャンバスを1つのPDFに書き出すことができる。
   やったことないけれどPostScriptでもできるらしい。PNGはできない。

   ROOT公式ユーザーズガイド “9. Graphics and the Graphical Userinterface : The Postscript Interface” (p139)参照

   #+begin_src c++
TString name;
name.Form("canv.pdf");
TCanvas *c1 = new TCanvas(name.Data(), name.Data(), 1000, 500);

c1->Print(name + "[", "pdf");    // ここで"canv.pdf"を開く感じ

for (Int_t ihist = 0; ihist < Nhists; ihist++) {
    hist[ihist]->Draw();
    c1->Print(name, "pdf")       // ここで、キャンバスを保存する
}
c1->Print(name + "]", "pdf");    // ここで"canv.pdf"を閉じる感じ
   #+end_src

   最後の一文を以下のように変更すれば、別のTCanvasオブジェクトを追加し
   て保存することができる。

   #+begin_src c++
c2->Print(name, "pdf")
c2->Print(name + "]", "pdf")
  #+end_src

*** “[“と”(“の違いについて

    - [ :: この時点ではページを出力しない
    - ( :: この時点でページを出力する（空白のページができる？）



* TLegend／TText編

* TString編

  C/C++では文字とか文字列の扱いは面倒くさいのですが、
  ROOTにはTStringという便利なクラスがあります。
  使わない手はないでしょう、ということで紹介しておきます。

** フォーマット文字列を作りたい

   #+begin_src c++
TString str;
str.Form("Hist%d", i);
   #+end_src

** 文字列を取り出す

   #+begin_src c++
str.Data();
   #+end_src

** 使い方の一例

   複数のヒストグラムをループで生成したいときなどによく使います。

   #+begin_src c++
   const Int_t nhist = 10;
   TString hname, htitle;
   for (Int_t i = 0; i < nhist; i++) {
       hname.Form("h%02d", i);
       htitle.Form("%s;%s;%s", hname.Data(), "x", "y");
       h[i] = new TH1D(hname.Data(), htitle.Data(), xbin, xmin, xmax);
   }
   #+end_src


* その他

  ここでは、ROOT以外の研究で役に立ちそうなことについてまとめます。

** Emacs

   最初に断っておくと、特に「Emacs信者」というわけではないです。Emacs
   しか使えない、ただのポンコツ[fn::Vimも基本操作はできるようにし
   といた方がよいと思っています]です。
   ただし、プログラミングを快適に行うにあたって「自分に合ったエディタ」
   を選択するというのは重要なことだと思います。思った以上に長いお付き
   合いになるので、愛着を持てるエディタを選びましょう。

   僕の場合は修士でプログラミングを始めた時に、最初に触ったのがEmacsだっ
   たというのが主な理由[fn::MacのCocoaアプリもEmacsキーバインドで使え
   るのも大きな理由だったかも]ですけどね。最初はこれまで使っていたテキ
   ストエディタ[fn::Wordやメモ帳]と同じように矢印キーなどで操作してい
   ました。ウェブなどでキーバインドを確認しながら、だんだんと操作方法
   を覚えていった気がします。

   最近では[[https://github.com/bbatsov/guru-mode][ guru-mode]] なるパッケージもあるので、これを入れて練習したら
   いいと思います。マニュアルにある通りにインストールして、(setq
   guru-warn-only t)にして使うとよいです。矢印キーなどを押すとミニバッ
   ファに適切なキーバインドが表示されるので、使いながら覚えるのにピッ
   タリです。後述するPreludeにはデフォルトで入っています（というか同じ
   作者）。


*** Emacsの学習コスト

   快適に操作をするためにある程度キーバインドを覚えないといけなかった
   り、カスタマイズしようと思うとElispの知識が必要だったり、と学習コス
   トは高め[fn::決して安くはない]です。

   プログラミングの統合開発環境には「Eclipse」や「Xcode」、文書作成に
   は「Word」だったり、TeXの統合環境には「EasyTeX」や「TeXShop」などが
   あります。これらは用途に特化していおり、便利になるように設計されて
   いるのですが、結局、各ソフト毎の操作を覚えなくてはいけないため、実
   は学習コストは同じくらいなんじゃないかなとも思います。


*** 基本操作

    操作方法を羅列するのは無意味なので、よく使う操作についてEmacs、vim、
    そしてlessを比較してみました。

**** ページ移動

     #+ATTR_LATEX: :environment longtable :align |l|l|l|l|
     | Emacs      | vim     | less   | 操作内容                   |
     | C-n        | j, RET  | j, RET | 次の行                     |
     | C-p        | k       | k      | 前の行                     |
     | C-v        | C-f     | SPC    | １ページ進む               |
     | M-v        | C-b     | S-SPC  | １ページ戻る               |
     | M-<        | gg      | g      | ファイルの先頭             |
     | M->        | G       | G      | ファイルの最後             |
     | M-g g 数値 | 数値 G  | :数値  | 指定した数値の行へジャンプ |
     |            |         | d      | 半ページ進む               |
     |            |         | u      | 半ページ戻る               |
     | C-x C-c    | :q, :q! | q      | ファイルを閉じる           |

**** カーソル移動

     #+ATTR_LATEX: :environment longtable :align |l|l|l|l|
     | Emacs | vim    | 操作内容                                                                               |
     | C-f   | l, SPC | 次の文字                                                                               |
     | C-b   | h      | 前の文字                                                                               |
     | M-f   | w, e   | 次の単語[fn::Emacsの場合、[[https://github.com/zk-phi/jaword][jawordパッケージ]] を導入すると日本語の単語移動が賢くなります] |
     | M-b   | b      | 前の単語                                                                               |
     | C-a   | 0      | 行頭                                                                                   |
     |       | ^      | 文頭（行頭にある文字）                                                                 |
     | C-e   | $      | 行末                                                                                   |
     | C-i   |        | タブ（インデント？）                                                                   |
     | C-l   |        | 画面の移動（上-中-下）                                                                 |

**** 切り貼り

     #+ATTR_LATEX: :environment longtable :align |l|l|l|l|
     | Emacs | vim        | 操作内容                             |
     | C-k   | d$         | カーソルの位置から行末までを切り取り |
     | C-w   | d$, dd, dw | 選択範囲を切り取り                   |
     |       | dd         | 一行削除（切り取り）                 |
     |       | dw         | １単語を切り取り                     |
     |       | d$, d^, d0 | それぞれ切り取り                     |
     | M-w   | y          | 選択範囲をコピー（yank）             |
     |       | yy         | 一行コピー（yank）                   |
     |       | yw         | １単語をコピー（yank）               |
     |       | y$, y^, y0 | それぞれコピー（yank）               |
     | C-y   | p          | 貼り付け                             |
**** 検索

     #+ATTR_LATEX: :environment longtable :align |l|l|l|l|
     | Emacs | vim            | 操作内容                                                                                                                                                                                |
     | C-s   | /文字, n, C-i  | 前方検索 [fn::Emacsの場合、[[https://github.com/koron/cmigemo][cmigemo]] と [[https://github.com/emacs-jp/migemo][migemoパッケージ]] を導入するとローマ字で日本語検索が可能になります。インストールと設定の詳細は [[http://rubikitch.com/2014/08/20/migemo/][るびきち「日刊Emacs」]] を参考にするとよいと思います] |
     | C-r   | ?文字, N, C-o  | 後方検索                                                                                                                                                                                |
     | C-@   | v              | マーカーのセット                                                                                                                                                                        |
     | M-%   | :s/old/new     | 現在行の最初の文字を置換（old -> new）                                                                                                                                                  |
     |       | :s/old/new/g   | 現在行のすべての文字を置換（old -> new）                                                                                                                                                |
     |       | :%s/old/new/gc | ファイル全体のすべての文字を、確認しながら置換                                                                                                                                          |

**** ファイル操作

     #+ATTR_LATEX: :environment longtable :align |l|l|l|l|
     | Emacs                                       | vim           | 操作内容                              |
     | C-x C-s                                     | :w            | ファイルを保存                        |
     | C-x C-w                                     | :w ファイル名 | ファイル名を指定して保存              |
     | C-x C-i                                     | :r ファイル名 | ファイル名の中身を挿入                |
     | C-d                                         | x             | カーソルの下の文字を削除（Delete）    |
     | C-h[fn::元々はHelpですが、置き換えています] | Backspace     | カーソルの左の文字を削除（Backspace） |



**** エディタ特有

    #+ATTR_LATEX: :environment longtable :align |l|l|l|l|
    | Emacs | vim       | 操作内容                                     |
    |       | ESC       | ノーマルモードへ切替                         |
    |       | i         | カーソルの位置に追加                         |
    |       | a         | カーソルの次の位置に追加                     |
    |       | A         | 行末に追加                                   |
    |       | I         | 行頭に追加                                   |
    |       | o         | カーソルの下の行に追加                       |
    |       | O         | カーソルの上の行に追加                       |
    | C-j   |           | 改行                                         |
    | C-o   |           | 改行                                         |
    | C-m   |           | 改行                                         |
    | RET   |           | 改行                                         |
    | C-x u | u         | 直前の動作の取り消し                         |
    |       | U         | 行全体の変更の取り消し                       |
    |       | C-r       | 取り消しの取り消し                           |
    |       | r         | カーソル下の１文字の置換                     |
    |       | R         | カーソル下の複数文字の置換                   |
    |       | cw        | カーソル位置の単語の変更（削除＋挿入）       |
    |       | c$        | カーソル位置から行末までの変更（削除＋挿入） |
    |       | c0        | カーソル位置から行頭までの変更（削除＋挿入） |
    |       | c^        | カーソル位置から文頭までの変更（削除＋挿入） |
    |       | C-g       | ファイル内の位置の表示                       |
    |       | %         | 対応するカッコへ移動                         |
    |       | !コマンド | 外部コマンドを実行                           |


*** キーボード設定

    Emacsを快適に操作するためには、少しだけキーボード設定をした方が良
    いと思います。あんまり変えすぎちゃうと、他のPCを使うときやPCを買い
    替えた時の再設定がめんどくさくなるので、ほどほどに。

    私の場合は以下の３点を変更しています。

    |                          | 変更前                   | 変更後                   |
    |--------------------------+--------------------------+--------------------------|
    | Controlキーの追加        | CapsLock                 | Control                  |
    | Spotlight検索            | Control + Space          | Option + Command + Space |
    | Select next input source | Option + Command + Space | OFF                      |


    #+attr_latex:  :width 0.7\textwidth
    #+caption: CapsLock \rightarrow Controlに変更
    [[./fig/mac-keyboard04.png]]

    #+attr_latex:  :width 0.7\textwidth
    #+caption: スポットライト検索のショートカットキーを変更する前。デフォルトは「Control + Space」
    [[./fig/mac-keyboard01.png]]

    #+attr_latex:  :width 0.7\textwidth
    #+caption: スポットライト検索のショートカットキーを「Option + Command + Space」に変更。重複するキーがあるため黄色い警告がでている
    [[./fig/mac-keyboard02.png]]

    #+attr_latex:  :width 0.7\textwidth
    #+caption: 「Select next source in input menu」なんてショートカットキーはこれまで使ったことない。なので無効にしても問題ない
    [[./fig/mac-keyboard03.png]]

*** Emacs + Org

    Emacs標準の「アウトラインモード」ですが、それ以上のことがたくさん
    できます。このKumaROOTもOrg-modeで作成しています[fn::Org-modeから
    LaTeXにエクスポート \rightarrow YaTeX環境でコンパイルしています。
    すべての作業がEmacs内でできるので大変便利です]。とても多機能なので、
    詳しくは「M-x org-info」でドキュメントを参照してください。

    ここでは、このKumaROOTを作成する際に必要だったことをメモする感じにします。

**** LaTeXエクスポートの設定

     pLaTeX（pTeX系）とpdfLaTeX（pdfTeX系）を使う場合を紹介しておきま
     す。日本語を使う場合、現在はpLaTeX（+dvipdfmx）を使う設定が簡単だ
     と思います。でも、調べてみると世の中はpdfLaTeXに向かっている気も
     するので、合わせて紹介しておきます。

     この辺は調べだすとキリがないので、軽い気持ちで選んだらいいと思い
     ます。

***** pLaTeXを使う場合

***** pdfLaTeXを使う場合

**** LaTeXエクスポートコマンド
     `C-c C-e l l     (`org-latex-export-to-latex')'
     `C-c C-e l p     (`org-latex-export-to-pdf')'

**** 使うクラスの指定

     org-latex-classes の中にあるクラスを使うことができる。
     新しいクラスを使いたい場合は、この alist に追加する必要がある。

     org-latex-default-classでデフォルトで使うクラスを指定できる。
     デフォルトは article。

     #+begin_src sh
#+latex_class: jsarticle
#+latex_class_options: [12pt]
#+latex_header: \usepackage{hoge}
     #+end_src

**** 脚注の挿入
**** 画像の挿入

     説明なしのリンクは画像として挿入される。
     挿入のときのオプションは「#+ATTR_LATEX:」で指定できる。
     画像の大きさは「:width 5cm」、「:height 10cm」のようにキーワード指定できる。
     他は「:options angle=90」のように :option キーワードで指定できる。
     キャプションは「#+caption:」で指定できる。

     まぁ、くどくど説明するより、以下のOrg文書での入力内容
     （[[src:image-input-in-org]]）と、それをLaTeXエクスポートしたときの出力内容
     （[[src:image-output-in-latex]]）を見てもらった方が早いと思います。

     #+caption: Org文書での入力内容
     #+name: src:image-input-in-org
     #+begin_src sh
#+attr_latex:  :width 0.7\textwidth
#+caption: CapsLock \rightarrow Controlに変更
[[./fig/mac-keyboard04.png]]
    #+end_src

     #+caption: LaTeXエクスポートしたときの出力内容
     #+name: src:image-output-in-latex
     #+begin_src latex
\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{./fig/mac-keyboard04.png}
\caption{CapsLock $\rightarrow$ Controlに変更}
\end{figure}
     #+end_src

**** 表の挿入

*** Emacs + Prelude

    Emacsの設定を一からするのってめんどくさいですよね。
    そんな場合はとりあえずググってみましょう。いろんな人が、いろんな形で公開しています。

    Preludeもその１つで、GitHubで公開されています。いろいろあって違い
    がよく分からなかったので、名前がかっこいいなーと思ってこれに決めま
    した。ほんとそれだけです。

    複数のマシンで同じEmacs設定を使いたい場合は、Preludeを自分のGitHub
    にForkして、Cloneするとよいと思います。

** LaTeX

   ほとんどの人は修論の時にLaTeXをがしがし使うことになると思います。そ
   の時に「インストールできないー」などと焦っていては時既に時間切れ
   [fn::ピンと来ない人は「ブロント語」でググってください]なので、簡単
   にまとめておきます。

*** MacTeXを使おう

    MacOSXでLaTeXを使う場合は、これで決まりです。
    TeX環境の本体であるTeXLiveと一緒に、TeX編集の統合環境である
    TeXShop[fn::修論の頃はお世話になりました。現在はYaTeXに移行したの
    で全く使っていません]やTeXworks、TeX関連のパッケージ管理ツールであ
    るTeX Live Utility[fn::コマンドラインからtlmgrとして使えます。パッ
    ケージのインストールがとても楽ちん。ただし、TeXLiveのバージョンが上
    がるたびに動かなくなるのでちょっとめんどくさい]、文献管理のBibDesk、
    スペルチェックのExcalibur、そして、Keynoteに数式を貼り付けるのに必
    要なLaTeXiT[fn::これが一番重宝してます]もついてきます。

**** 日本語とLaTeX

     日本語はマルチバイトコードであるため、LaTeXでコンパイルするのが難
     しかったみたいです。それに対処する歴史的な紆余曲折から日本語版
     LaTeXにはさまざまな派生品が存在します。この歴史の詳細に関しては、
     三重大学の奥村さんのウェブサイトをはじめ、ググってみるとよいでしょ
     う。

     つい最近までは「Mac LaTeX インストール」などでググると、なんだか
     まとまりのない情報で溢れていました。しかし、現在はそれらを取りま
     とめようということで開発が進んでいるようで、これからはTeXLive一択
     で良いみたいです。

     TeXLiveはMacPortsからインストールすることもできますが、うまく設定
     できた試しがありません。なので、[[https://tug.org/mactex/][MacTeX公式ページ]] に置いてある
     MacTeXパッケージをダウンロード[fn::フルパッケージは2GBちょいあるの
     で、ダウンロードに少し時間がかかります。細い回線で行うのはオススメ
     しません]するのが一番簡単で良いと思います。


*** ptex2pdf を使おう

    日本語のLaTeX文書をコンパイルするにはpLaTeXコマンドを使います。コ
    ンパイルが成功するとdviファイルが作成されるので、dvipdfmxコマンド
    を使ってPDFファイルに変換します。

    これをまとめてやってくれるのがptex2pdfコマンドで、（おそらく）
    MacTeXをインストールすると勝手についてきます。ただのシェルスクリプ
    トなので、気になる人は中を見てみるとよいでしょう。


*** YaTeXを使おう

    MacTeXをインストールするとTeXShop.appがついてきます。
    すぐに使えるので、時間に余裕がないときはこちらを使うと良いでしょう。

    設定に時間を割けるようであれば、Emacs+YaTeXをおすすめします。YaTeX
    の設定や操作コマンドを覚えるための時間は必要ですが、ある程度慣れて
    しまえば編集作業が格段に捗るはずです。

    http://ichiro-maruta.blogspot.jp/2013/03/latex.html
    http://qiita.com/zr_tex8r/items/5413a29d5276acac3771


*** pdfLaTeX

*** jsarticleドキュメントクラス

     #+begin_src latex
\documentclass[dvipdfmx,12pt]{jsarticle}
     #+end_src

    日本語のLaTeX文書にはjsarticleドキュメントクラスを使います。
    ドライバはdvipdfmxを使います。

*** graphicxパッケージ

     #+begin_src latex
\usepackage[hiresbb]{graphicx}
     #+end_src

    画像を扱う場合はgraphicxパッケージを使います。
    ドライバはdvipdfmxを使います。ドキュメントクラス指定時に宣言していてれば、ここで指定する必要はありません。
    画像のバウンディングボックスに「HiResBoundingBox」を使う場合は、hiresbbオプションを付けておきます。

*** hyperrefパッケージ

    LaTeX文書内にハイパーリンクを置く場合には、hyperrefパッケージを使うとよい。
    しかし、日本語のドキュメントクラスを使うとページから文章がはみ出たり、目次のしおりが文字化けしたりするので、以下のように対処する必要がある。

**** PXjahyperパッケージも読み込む

     #+begin_src latex
\usepackage{pxjahyper}
     #+end_src

     PXjahyperパッケージを読み込んでおけば、万事解決するみたい。
     それでも解決しない場合は、以下のように個別に対処する。

**** ページサイズ対策

     #+begin_src latex
\hypersetup{setpagesize=false}
     #+end_src

**** しおりの文字化け対策

     #+begin_src latex
\usepackage{atbegshi}
\AtBeginShipoutFirst{\special{pdf:tounicode EUC-UCS2}}
\AtBeginShipoutFirst{\special{pdf:tounicode 90ms-RKSJ-UCS2}}
     #+end_src

     何をしてくのか全く分かっていないけれど、両方書いておけばいい。
     それでだめな場合は片方にする。

** KiNOKO

   CAMACやVMEでデータ収集を行うためのドライバをインストールします。
   詳細に関しては「[[http://www.awa.tohoku.ac.jp/~sanshiro/kinoko/index.html][KiNOKOプロジェクト]]」を参照してください。

#+begin_src sh
$ cd ~/Downloads/
$ wget http://www.awa.tohoku.ac.jp/~sanshiro/kinoko-download/files/kinoko-2014-01-29.tar.gz
$ tar zxvf kinoko-2014-01-29.tar.gz /usr/local/heplib/
#+end_src

   僕の場合、ダウンロードしたファイルはとりあえず ~/Downloads に保存することにしています。
   また、高エネルギー物理関連のプログラムは /usr/local/heplib/ 以下にインストールすることにしています。

*** CAMACドライバのインストール

*** VMEドライバのインストール

** Geant4
